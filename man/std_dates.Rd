% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/std_date.R
\name{std_dates}
\alias{std_dates}
\title{Parse Dates to Standard Format}
\usage{
std_dates(
  x,
  force = c("none", "dt", "dttm"),
  train = TRUE,
  orders = c("mdy", "dmy", "ymd", "mdyT", "dmyT", "ymdT", "mdyR", "dmyR", "ymdR",
    "mdyr", "dmyr", "ymdr", "mdyTz", "dmyTz", "ymdTz", "Tmdyz", "Tdmyz", "Tymdz",
    "mdyRz", "dmyRz", "ymdRz", "mdyrz", "dmyrz", "ymdrz", "Tmdy", "Tdmy", "Tymd",
    "Tmdyz", "Tdmyz", "Tymdz"),
  ...
)
}
\arguments{
\item{x}{A vector of character dates}

\item{force}{Whether to force conversion to \code{Date} (\code{force = "dt"}) or
\code{POSIXct} (\code{force = "dttm"}). The default is no forcing (\code{force = "none"}).}

\item{train}{logical, default \code{TRUE}. Whether to train formats on a subset of
the input vector. The result of this is that supplied orders are sorted
according to performance on this training set, which commonly results in
increased performance. Please note that even when \code{train = FALSE} (and
\code{exact = FALSE}) guessing of the actual formats is still performed on a
pseudo-random subset of the original input vector. This might result in
\verb{All formats failed to parse} error. See notes below.}

\item{orders}{The orders to use when parsing character vector with
\code{\link[lubridate:parse_date_time]{parse_date_time()}}}

\item{...}{Additional arguments to pass to
\code{\link[janitor:convert_to_date]{convert_to_datetime()}}. These
will, in turn, be passed to further methods, including
\code{\link[janitor:excel_numeric_to_date]{excel_numeric_to_date()}},
\code{\link[lubridate:parse_date_time]{parse_date_time()}}, and
\code{\link[base:as.POSIXct]{as.POSIXct()}}.}
}
\value{
A \code{Date} or \code{POSIXct} vector
}
\description{
\code{std_dates} standardizes a date vector and returns a vector in \code{Date} or
\code{POSIXct} format, depending on whether there is sub-daily information
available in the data.
}
