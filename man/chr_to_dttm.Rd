% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/std_date.R
\name{chr_to_dttm}
\alias{chr_to_dttm}
\title{Parse Dates in Character Format to Datetime Format}
\usage{
chr_to_dttm(
  x,
  tz = "UTC",
  orders = c("mdy", "dmy", "ymd", "mdyT", "dmyT", "ymdT", "mdyR", "dmyR", "ymdR",
    "mdyr", "dmyr", "ymdr", "mdyTz", "dmyTz", "ymdTz", "Tmdyz", "Tdmyz", "Tymdz",
    "mdyRz", "dmyRz", "ymdRz", "mdyrz", "dmyrz", "ymdrz", "Tmdy", "Tdmy", "Tymd",
    "Tmdyz", "Tdmyz", "Tymdz"),
  train = TRUE,
  ...
)
}
\arguments{
\item{x}{A vector of character dates}

\item{tz}{Optional timezone}

\item{orders}{The orders to use when parsing character vector with
\code{\link[lubridate:parse_date_time]{parse_date_time()}}}

\item{train}{logical, default \code{TRUE}. Whether to train formats on a subset of
the input vector. The result of this is that supplied orders are sorted
according to performance on this training set, which commonly results in
increased performance. Please note that even when \code{train = FALSE} (and
\code{exact = FALSE}) guessing of the actual formats is still performed on a
pseudo-random subset of the original input vector. This might result in
\verb{All formats failed to parse} error. See notes below.}

\item{...}{Additional arguments to pass to
\code{\link[lubridate:parse_date_time]{parse_date_time()}}}
}
\value{
A \code{POSIXct} vector
}
\description{
\code{chr_to_dttm} standardizes a datetime vector in character format and returns
a vector in \code{POSIXct} format.
}
